## ETH 批量转账功能 MVP 技术文档

### 1\. 整体技术方案概述

本项目将采用当前主流的**前后端分离架构**。前端负责用户界面和与区块链钱包的交互，后端提供 API 接口用于任务管理、数据存储和区块链交易状态的查询。核心的批量转账逻辑将封装在一个优化的**智能合约**中，确保交易的原子性和链上透明性。

**技术栈概览：**

  * **前端：** React.js + Ethers.js
  * **后端：** Java 17 + Spring Boot 3 + MyBatis
  * **数据库：** MySQL 8+
  * **智能合约：** Solidity
  * **开发工具：** Foundry (智能合约开发), Maven (Java 构建)
  * **版本控制：** Git

### 2\. 架构设计

#### 2.1. 系统架构图

```mermaid
graph TD
    A[用户浏览器/客户端] -->|HTTPS| B(前端应用 - React.js)
    B -->|Web3 Wallet (e.g., MetaMask)| C[区块链网络 (Ethereum)]
    B -->|HTTPS API| D(后端服务 - Spring Boot)
    D -->|JDBC| E[MySQL 数据库]
    D --o|Web3j/Ethers.js (Node)| C

    C -- Tx Status --> D
    C -- Event Log --> D
    C -- RPC Call --> C

    subgraph 区块链层
        C -- 调用 --> F(批量转账智能合约)
    end
```

#### 2.2. 各层职责

  * **用户浏览器/客户端：** 用户通过浏览器访问前端应用。
  * **前端应用 (React.js)：**
      * 提供批量转账任务的创建、管理和展示界面。
      * 处理用户输入、文件上传和格式校验。
      * 通过 Web3 钱包（如 MetaMask）直接与以太坊区块链交互，包括连接钱包、发起智能合约调用（签名交易）。
      * 通过 HTTPS API 与后端服务通信，进行任务的创建、查询和状态同步。
  * **后端服务 (Spring Boot)：**
      * **API 层：** 提供 RESTful API 供前端调用，处理批量转账任务的 CRUD 操作。
      * **业务逻辑层：** 接收前端请求，执行业务规则校验（如任务命名、文件解析等），并协调与数据库和区块链的交互。
      * **数据访问层：** 使用 MyBatis 与 MySQL 数据库交互，存储和查询任务数据。
      * **区块链同步服务：** 负责异步监听或查询区块链上的交易状态，更新本地数据库中任务的状态。这个服务不会直接发送链上交易，而是监听前端发起交易后的状态变化。
  * **MySQL 数据库：** 存储批量转账任务的元数据、状态以及每笔子转账的详细信息。
  * **区块链网络 (Ethereum)：**
      * 承载已部署的批量转账智能合约。
      * 处理所有链上交易。
  * **批量转账智能合约 (Solidity)：**
      * 核心业务逻辑，负责接收批量转账请求，并原子性地将 ETH 分发到多个目标地址。

### 3\. 智能合约设计 (Solidity)

#### 3.1. 核心功能

  * 接收一个接收地址数组 (`address[]`) 和一个金额数组 (`uint256[]`)。
  * 遍历数组，将对应的 ETH 转账给每个地址。
  * 确保整个转账过程的原子性：要么所有转账都成功，要么所有转账都失败并回滚（Solidity 默认行为）。
  * **事件 (Events)：** 触发事件以方便后端服务监听和追踪交易状态。

#### 3.2. 合约示例 (简要，仅供参考)

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract BatchTransfer {
    // 定义一个事件，用于记录批量转账的开始
    event BatchTransferInitiated(address indexed caller, uint256 totalAmount, uint256 numRecipients, uint256 timestamp);
    // 定义一个事件，用于记录每次子转账的成功与否（可选，但更详细）
    event SingleTransferResult(address indexed recipient, uint256 amount, bool success, string message);

    /**
     * @dev 批量转账ETH给多个地址
     * @param _recipients 接收地址数组
     * @param _amounts 对应每个接收地址的ETH金额数组 (单位: Wei)
     */
    function batchTransfer(address[] calldata _recipients, uint256[] calldata _amounts) external payable {
        // 确保发送的 ETH 总量与 _amounts 数组中所有金额的总和一致
        require(msg.value == getTotalAmount(_amounts), "Total amount sent does not match sum of individual amounts.");
        // 确保接收地址和金额数组长度一致
        require(_recipients.length == _amounts.length, "Recipient and amount arrays must have same length.");
        // 确保数组不为空
        require(_recipients.length > 0, "Recipient array cannot be empty.");

        // 触发批量转账开始事件
        emit BatchTransferInitiated(msg.sender, msg.value, _recipients.length, block.timestamp);

        // 遍历并转账
        for (uint i = 0; i < _recipients.length; i++) {
            address payable recipient = payable(_recipients[i]);
            uint256 amount = _amounts[i];

            // 使用 call 而不是 transfer/send 以避免 2300 Gas limit 问题，
            // 并且更好地处理失败情况。
            // 这里的 require 确保了每笔转账都成功，否则整个交易将回滚。
            // 如果希望支持部分成功，需要更复杂的逻辑，这超出了MVP范围。
            (bool success, ) = recipient.call{value: amount}("");
            require(success, string(abi.encodePacked("Failed to transfer ETH to ", Strings.toHexString(uint160(recipient)))));

            // 触发单笔转账结果事件 (可选)
            emit SingleTransferResult(recipient, amount, true, "Success");
        }
    }

    /**
     * @dev 计算金额数组的总和
     * @param _amounts 金额数组
     * @return 总金额
     */
    function getTotalAmount(uint256[] calldata _amounts) internal pure returns (uint256) {
        uint256 total = 0;
        for (uint i = 0; i < _amounts.length; i++) {
            total += _amounts[i];
        }
        return total;
    }
}

// 辅助库，用于地址到十六进制字符串转换（如果需要更友好的错误信息）
// import "@openzeppelin/contracts/utils/Strings.sol"; // 需要安装OpenZeppelin Contracts
```

#### 3.3. 开发与测试

  * 使用 **Hardhat** 或 **Foundry** 进行合约开发、测试和部署。
  * 编写单元测试和集成测试，确保合约逻辑的正确性和 Gas 效率。
  * 在 Sepolia 或 Holesky 等测试网上进行充分测试。

### 4\. 后端服务设计 (Java Spring Boot + MyBatis)

#### 4.1. 技术栈

  * **语言：** Java 17
  * **框架：** Spring Boot 3
  * **ORM：** MyBatis (非 MyBatis-Plus)
  * **数据库：** MySQL 8+
  * **区块链交互库：** Web3j
  * **依赖管理：** Maven 或 Gradle
  * **日志：** SLF4J + Logback

#### 4.2. 数据模型 (MySQL)

**`batch_transfer_tasks` 表：** 存储批量转账任务的主信息。

| 字段名         | 类型         | 约束         | 描述               |
| :------------- | :----------- | :----------- | :----------------- |
| `id`           | BIGINT       | PRIMARY KEY, AUTO\_INCREMENT | 唯一任务ID         |
| `task_name`    | VARCHAR(255) | NOT NULL     | 任务名称           |
| `total_recipients` | INT          | NOT NULL     | 总接收地址数量     |
| `total_amount` | DECIMAL(28,18) | NOT NULL     | 总转账金额 (ETH)   |
| `status`       | VARCHAR(50)  | NOT NULL     | 任务状态 (PENDING, EXECUTING, COMPLETED, FAILED) |
| `tx_hash`      | VARCHAR(255) | NULL         | 链上交易哈希       |
| `error_message` | TEXT         | NULL         | 错误信息           |
| `created_at`   | TIMESTAMP    | NOT NULL, DEFAULT CURRENT\_TIMESTAMP | 创建时间           |
| `updated_at`   | TIMESTAMP    | NOT NULL, DEFAULT CURRENT\_TIMESTAMP ON UPDATE CURRENT\_TIMESTAMP | 最后更新时间       |

**`batch_transfer_items` 表：** 存储每个批量转账任务中的详细转账项。

| 字段名         | 类型         | 约束         | 描述               |
| :------------- | :----------- | :----------- | :----------------- |
| `id`           | BIGINT       | PRIMARY KEY, AUTO\_INCREMENT | 唯一项ID           |
| `task_id`      | BIGINT       | NOT NULL     | 关联的任务ID       |
| `recipient_address` | VARCHAR(255) | NOT NULL     | 接收地址           |
| `amount`       | DECIMAL(28,18) | NOT NULL     | 转账金额 (ETH)     |
| `status`       | VARCHAR(50)  | NOT NULL     | (可选) 子项状态，MVP 可依赖主任务状态 |
| `created_at`   | TIMESTAMP    | NOT NULL, DEFAULT CURRENT\_TIMESTAMP | 创建时间           |

**索引考虑：**

  * `batch_transfer_tasks`: `(status, created_at)` 用于快速查询不同状态的任务。
  * `batch_transfer_items`: `(task_id)` 用于快速查询某个任务下的所有转账项。

#### 4.3. API 设计 (RESTful)

**基础 URL：** `/api/v1/batch-transfers`

  * **创建批量转账任务**
      * **POST** `/api/v1/batch-transfers`
      * **请求体：**
        ```json
        {
          "taskName": "My First Batch Transfer",
          "transferItems": [
            {"address": "0x...", "amount": 0.1},
            {"address": "0x...", "amount": 0.05}
          ]
        }
        ```
      * **响应：**
        ```json
        {
          "id": 123,
          "taskName": "My First Batch Transfer",
          "totalRecipients": 2,
          "totalAmount": 0.15,
          "status": "PENDING",
          "createdAt": "2025-07-30T10:00:00Z"
        }
        ```
  * **获取所有批量转账任务列表**
      * **GET** `/api/v1/batch-transfers`
      * **响应：** 任务列表数组
  * **获取单个批量转账任务详情**
      * **GET** `/api/v1/batch-transfers/{taskId}`
      * **响应：** 任务对象及 `transferItems` 数组
  * **更新批量转账任务状态 (内部 API，由区块链监听服务调用)**
      * **PUT** `/api/v1/batch-transfers/{taskId}/status`
      * **请求体：**
        ```json
        {
          "status": "COMPLETED",
          "txHash": "0x...",
          "errorMessage": "Optional error message"
        }
        ```
      * **响应：** 更新后的任务对象

#### 4.4. 核心业务流程

1.  **前端任务创建：**
      * 用户通过界面输入或上传转账列表。
      * 前端进行初步校验。
      * 前端调用后端 `POST /api/v1/batch-transfers` API，保存任务信息到 MySQL，初始状态为 `PENDING`。
      * 后端返回创建成功的任务 ID。
2.  **前端触发执行：**
      * 用户选择一个 `PENDING` 状态的任务，点击“执行”。
      * 前端从后端获取该任务的详细转账列表（接收地址和金额）。
      * 前端将地址和金额转换为 `Wei` 单位，并通过 Ethers.js/Web3.js 构建智能合约调用。
      * 前端请求用户通过 MetaMask 签名并发送交易。
      * 一旦交易发送成功并获得 `txHash`，前端**立即**将 `txHash` 和任务状态 `EXECUTING` 更新到后端（调用 `PUT /api/v1/batch-transfers/{taskId}/status`）。
3.  **后端交易状态监听：**
      * 后端服务有一个独立的**区块链监听服务**（可以是一个定时任务或更高级的基于 WebSocket 的监听器）。
      * 该服务会定期（例如每 10-30 秒）查询所有状态为 `EXECUTING` 的任务。
      * 对于每个 `EXECUTING` 任务，利用 `Web3j` 根据 `txHash` 查询以太坊网络上的交易收据 (Transaction Receipt)。
      * 根据收据的 `status` (0x1 成功, 0x0 失败) 更新 `batch_transfer_tasks` 表中的任务状态为 `COMPLETED` 或 `FAILED`，并记录任何错误信息。

#### 4.5. Java 代码结构 (Maven)

```
├── pom.xml
├── src
│   ├── main
│   │   ├── java
││   │   │   └── com
││   │   │       └── webthree
││   │   │           └── batchtransfer
││   │   │               ├── BatchTransferApplication.java  // Spring Boot 主应用
││   │   │               ├── config
││   │   │               │   └── Web3jConfig.java         // Web3j 配置
││   │   │               │   └── MybatisConfig.java       // MyBatis 配置
││   │   │               ├── controller
││   │   │               │   └── BatchTransferController.java // RESTful API 控制器
││   │   │               ├── entity
││   │   │               │   ├── BatchTransferTask.java   // 任务实体类
││   │   │               │   └── BatchTransferItem.java   // 任务项实体类
││   │   │               ├── mapper
││   │   │               │   ├── BatchTransferTaskMapper.java // MyBatis Mapper 接口
││   │   │               │   └── BatchTransferItemMapper.java // MyBatis Mapper 接口
││   │   │               ├── service
││   │   │               │   ├── BatchTransferService.java    // 业务逻辑服务
││   │   │               │   └── BlockchainMonitorService.java // 区块链监听服务
││   │   │               └── util
││   │   │                   └── EthUtils.java            // ETH 单位转换等工具类
│   │   │   └── resources
│   │   │       ├── application.yml                 // Spring Boot 配置
│   │   │       ├── mybatis                        // MyBatis XML Mapper 文件目录
│   │   │       │   ├── BatchTransferTaskMapper.xml
│   │   │       │   └── BatchTransferItemMapper.xml
│   │   │       └── logback-spring.xml              // 日志配置
│   └── test
│       └── java
│           └── com
│               └── webthree
│                   └── batchtransfer
│                       └── ... // 单元测试和集成测试
```

#### 4.6. MyBatis 使用实践

  * **Mapper 接口：** 定义纯粹的 Java 接口，不使用 `@Mapper` 注解，而是通过 `@MapperScan` 在 Spring Boot 应用启动时扫描。
  * **XML Mapper 文件：** 将 SQL 语句完全定义在 XML 文件中，实现业务逻辑与 SQL 分离。例如：
      * `BatchTransferTaskMapper.xml`
      * `BatchTransferItemMapper.xml`
  * **动态 SQL：** 充分利用 MyBatis 的 `<if>`, `<where>`, `<foreach>` 等标签来构建灵活的 SQL 语句。
  * **事务管理：** 利用 Spring 的 `@Transactional` 注解进行声明式事务管理，确保数据库操作的原子性。

#### 4.7. 区块链交互 (Web3j)

  * **配置 `Web3jConfig.java`：** 配置连接到以太坊节点的 `Web3j` 实例。推荐使用专业的 RPC 服务提供商（如 Infura, Alchemy），而不是自建节点，以提高稳定性和可用性。
  * **异步查询：** `Web3j` 支持异步操作，在 `BlockchainMonitorService` 中应利用这一点，避免阻塞主线程。
  * **处理 `BigInteger` 和 `BigDecimal`：** 以太坊金额通常用 `Wei` (BigInteger) 表示，在 Java 后端处理时注意 `Wei` 和 `ETH` (BigDecimal) 之间的转换。

### 5\. 前端设计 (React.js + Ethers.js)

#### 5.1. 技术栈

  * **框架：** React.js
  * **状态管理：** React Context API 或 Redux (小型项目 Context API 足够)
  * **UI 组件库：** Ant Design / Material-UI (提供开箱即用的组件)
  * **Web3 库：** Ethers.js (轻量、功能全面，推荐) 或 Web3.js
  * **HTTP 请求：** Axios
  * **打包工具：** Vite / Webpack

#### 5.2. 核心组件

  * **ConnectWalletButton：** 连接/断开 MetaMask 等钱包。
  * **BatchTransferForm：** 用于上传文件或手动输入转账列表。
  * **TaskList：** 显示所有批量转账任务列表。
  * **TaskDetailModal/Page：** 显示单个任务的详细信息。
  * **ConfirmationModal：** 在发送交易前，显示 Gas 预估和总金额，供用户确认。

#### 5.3. 与区块链交互

  * **连接钱包：** 使用 Ethers.js 的 `Web3Provider` 连接 MetaMask。
  * **合约实例：** 创建智能合约的 Ethers.js `Contract` 实例，通过合约 ABI 和地址进行交互。
  * **发送交易：** 调用合约实例的方法，Ethers.js 会自动触发 MetaMask 弹出签名确认。
  * **错误处理：** 捕获 MetaMask 或区块链返回的错误，并友好地展示给用户。

### 6\. 部署方案 (MVP 推荐)

#### 6.1. 后端部署

  * **Jar 包部署：** 将 Spring Boot 应用打包成可执行 Jar 包，部署到云服务器（如 AWS EC2, Aliyun ECS）。
  * **Docker 容器化 (推荐)：**
      * 创建 Dockerfile，将 Spring Boot 应用打包成 Docker 镜像。
      * 部署到 Docker 主机或 Kubernetes 集群。
      * **优点：** 环境一致性、易于扩展、资源隔离。

#### 6.2. 数据库部署

  * **独立 MySQL 实例：** 部署在独立的服务器或云数据库服务（如 AWS RDS, Aliyun RDS）。
  * **Docker 容器化：** MySQL 也可以容器化部署。

#### 6.3. 前端部署

  * **Nginx 静态文件服务：** 将 React 应用打包后的静态文件部署到 Nginx 服务器，对外提供访问。
  * **CDN (可选)：** 如果有全球用户，可以考虑使用 CDN 加速。

#### 6.4. 智能合约部署

  * 使用 Hardhat/Foundry 部署到选定的以太坊网络（测试网或主网）。
  * **合约地址**和 **ABI** 需要在前端和后端中配置。

### 7\. 安全考虑与最佳实践

  * **私钥安全：** 强调私钥绝不离线，所有签名操作必须在用户本地钱包完成。
  * **输入验证：** 前后端都要对用户输入和上传文件进行严格的格式、类型和业务逻辑校验，防止恶意数据。
  * **HTTPS：** 强制所有通信使用 HTTPS。
  * **SQL 注入防护：** MyBatis 配合预编译语句天然防止 SQL 注入，但仍需注意避免手动拼接 SQL。
  * **智能合约审计：** MVP 阶段可简化，但正式上线前务必进行专业审计。
  * **错误日志与监控：** 完善日志记录，集成监控系统，及时发现并处理生产环境问题。
  * **配置管理：** 将数据库连接、RPC URL、合约地址等敏感配置外部化，不要硬编码在代码中。使用 Spring Boot 的配置文件或环境变量。
  * **并发控制：** 确保后端在处理任务状态更新时，考虑到并发访问可能导致的数据不一致问题（例如，使用乐观锁或数据库事务）。